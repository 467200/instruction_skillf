[< к содержанию](readme.md)


### БАЗОВЫЕ КОМАНДЫ:
Ввод команд производится на терминале (_Linux и MacOS_) или на консоле (_Windows_).


### **git add** <br/>
**git add *[файл]*** - добавляет файл в индекс.<br/>
Чтобы добавить все файлы в каталоге в индекс (кроме игнорируемых), используется команда 

```bash=
git add 
```

### **git init** <br/>
**git init** -  создаёт в текущей директории новую поддиректорию с именем *.git*, содержащую все необходимые файлы [репозитория](dictionary.md) — структуру Git-репозитория. Вводится команда 

```bash=
git init 
```
### **git status** <br/>
**git status** - показывает состояния файлов в рабочем каталоге и индексе: какие файлы изменены, но не добавлены в индекс; какие ожидают [коммита](dictionary.md) в индексе, выводятся подсказки о том, как изменить состояние файлов. Чтобы увидеть состояние, использыется команда
```bash=
git status
```
### **git log** <br/>
После того как создано несколько коммитов, или  склонирован репозиторий с уже существующей историей коммитов, если захочется оглянуться назад и узнать, что происходило с этим репозиторием, наиболее простой и в то же время мощный инструмент для этого — команда
```bash=
git log
```
### **git show** <br/>
Данная команда покажет информацию по определённому коммиту:
```bash=
git show [хэш]
```
### **git commit** <br/>

При выполнении команды **git commit** изменения всех файлов, внесённые в индекс, переносятся в репозиторий. При создании коммита (точки фиксации изменений) требуется указать сообщение.<br/>
Примеры сообщений коммитов:
```bash=
git commit -m «init»
```
```bash=
git commit -m «сообщение»
```
```bash=
git commit -m «add invoices»
```
### **git reset** <br/>
Чтобы отменить изменения использыется команда **git reset**. Это мощная команда, используемая для отмены локальных изменений в репозитории **Git**. _Git reset_ работает с «тремя деревьями __Git__»: историей коммитов (HEAD ), разделом проиндексированных файлов и рабочим каталогом.Это одна из команд (*Git checkout, git clean, git revert, git reset, git rm*) по отмене коммитов и изменений. Пример сброса истории коммитов до указанного коммита:
```bash=
git reset --hard a1e8fb5
```
### **git clone** <br/>
Команда **git clone** служит для создания копии репозитория (локального или удаленного).То есть мы просим **Git** создать копию репозитория, который находится по ссылке (<ссылка на репозиторий>), и можем указать название новой папки, в которую Git скопирует репозиторий (<название папки>). Если его не указать, папка будет называться так же, как и сам репозиторий.
```bash=
git clone <ссылка на репозиторий> <название папки>
```
### **git remote add** <br/>
С помощью данной команды устанавливается подключение к удаленному серверу и git репозиторию на нем. Т.е. она используется для добавления связанных удаленных репозиториев:
```bash=
git remote add [имя_удаленного_репозитория] [адрес]
```
### **git fetch** <br/>
Команда git fetch запросит с удаленного репозитория список изменений и запишет в локальный репозиторий. Но при этом ни происходит попыток слияния, только получение новых данных.
### **git merge** <br/>
**git merge** используется для слияния полученных изменений и локального репозитория, то есть на практике для слияния [веток](dictionary.md). При этом сначала надо перключиться на ветку мастер, затем выполнить слияние ветки мастер с другой веткой. При этом изменения, сделанные в другой ветке, "вливаются" в мастер:
```bash=
git checkout master
```
```bash=
git merge [имя ветки]
```
### **git pull** <br/>
По сути, **git pull** — это сочетание команд *git fetch* (загружает коммиты, ссылки, файлы из удаленного репозитория в локальный) и *git merge* (объединяет несколько коммитов в один общий).<br/>
На первой стадии **git pull** выполняется команда *fetch*, ограниченная локальной веткой. Затем команда **git pull** выполняет слияние и формируется новый коммит.
### **git push** <br/>
Команда **Git push** позволяет отправлять локальную ветку на удаленный репозиторий. Она помогает разработчикам синхронизироваться в команде, а именно отправляет проделанные изменения. Если программист работает один, то пуш позволяет хранить код в облаке, избавляя от риска потери данных на компьютере. Перед пушем надо зафиксировать текущие изменения, то есть сделать *git commit*. Затем вводится команда
```bash=
git push origin <название ветки> 
```