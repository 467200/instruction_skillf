## Ветвление
Ветвление стало неотъемлемой частью командной разработки, потому что оно дает возможность работать над разными версиями исходного кода. Основной идеей ветвления является отклонение от основного кода и продолжение работы независимо от него. Также это удобно в тестировании отдельного функционала, потому что позволяет работать над новой частью кода, не беспокоясь о поломке чего-то в рабочей версии.<br/>
Способ ветвления в **Git** чрезвычайно легковесен, что делает операции ветвления практически мгновенными и переключение туда-сюда между [ветками](dictionary.md) обычно так же быстрым. В отличие от многих других [СКВ](dictionary.md), **Git** поощряет процесс работы, при котором ветвление и слияние осуществляется часто, даже по несколько раз в день. Понимание и владение этой функциональностью даёт уникальный мощный инструмент и может буквально изменить то, как вести разработку.<br/>
Под веткой принято понимать независимую последовательность коммитов в хронологическом порядке. В **Git** реализация ветки выполнена как указатель на последний коммит в рассматриваемой ветке. После создания ветки уже новый указатель ссылается на текущий коммит.
Имя основной ветки **Git**-проекта по умолчанию — *master* или *main*, она появляется сразу при инициализации репозитория.<br/>
Команда ***git branch*** — главный инструмент для работы с ветвлением.<br/>
Чтобы в Git добавить ветку мы используем:
```bash=
git branch <название ветки> 
```
После данной операции ветка уже была создана, но вы по-прежнему находитесь в прежней ветке. Если вы планируете переместиться на другую ветку, в том числе только что созданную, необходимо написать checkout:
```bash=
git checkout <название ветки> 
```
Чаще всего при создании новой ветки **Git** пользователю необходимо сразу же переключиться на нее. В таком случае стоит использовать:
```bash=
git checkout branch <название ветки> 
```
И также мы получим тот же результат при использовании **Git** checkout с ключом -b:
```bash=
git checkout -b <название ветки> 
```

Если нужно получить список определенного множества веток, то тогда можно воспользоваться ***ключами***. Одними из самых распространенных будут:

+ -r — при использовании этого ключа мы получим список удаленных веток,
+ -a — используя этот параметр, в выводе будут удаленные и локальные ветки.

После того, как разработчик убедился, что написанный им кусок кода готов и его можно отправить к остальной части итоговой версии, удобно переместить его в основную ветку. Такой подход дает возможность получить к концу разработки проекта целый продукт в одном месте.
Для этого в **Git** предусмотрено слияние — перенос изменений с одной ветки на другую. Однако сливаемая ветка (под этим определением мы подразумеваем ветку, у которой берем изменения для «вливания» их в другую ветвь) никак не меняется и остается в прежнем состоянии. Такие преобразования мы получаем, применив команду *git merge*:
```bash=
git merge <название ветки> 
```

Однако эта операция может привести к появлению **конфликтов** при попытке слить ветки. Это вызвано тем, что изменения удаляют или переписывают информацию в существующих файлах. При попытке некорректного слияния **Git** останавливает выполнение команды, чтобы можно было разрешить конфликт.

Здесь стоит упомянуть о существовании ***ключей***, предназначенных специально для работы с конфликтами:

+ —abort — прерывает слияние и возвращает все к началу
+ —continue — продолжает слияние после разрешения конфликта <br/>

Решить **конфликт** можно двумя способами:

1. Вручную разрешить файловый конфликт. Для этого нужно самим изменить файлы, с которыми возникли проблемы. Мы получим файлы такими, какими и представляли их при попытке слияния.
2. Выбрать более подходящий файл, а от второго отказаться.<br/>

При работе с **Git** важно выбрать ***ПОДХОДЯЩУЮ МОДЕЛЬ ВЕТВЛЕНИЯ***, максимально отвечающую потребностям команды. Существует множество различных моделей.<br/>
1. *Central Workflow*-идеально подходит для одиночного проекта.Репозиторий содержит только одну главную ветку *master (main)*. Все изменения комитятся в нее. Репозиторий может быть локальным, без удаленных копий или храниться удаленно, где он может быть клонирован или запушен.
2.  *Developer Branch Workflow* - больше подойдет для небольшого проекта с ограниченным количеством требований и небольшим количеством разработчиков, которым нужно чтобы их изменения в проекте были просмотрены до слияния с веткой *master (main)*.У каждого разработчика есть своя личная ветка или несколько, в которые он пушит. Все изменения, опубликованные в удаленном репозитории будут в этой ветке. Вся работа может быть выполнена на разных ветках, но потом должна будет слита (*merged*) в одну главную ветвь.
3. *Feature Branch Workflow* - основная ее идея заключается в том, что вся работа над новой функциональностью должна производится в отдельной ветке, а не в ветке *master*. Такая инкапсуляция облегчает работу нескольких разработчиков над общей функциональностью в рамках одной кодовой базы. Также это значит, что нерабочий код никогда не попадет в ветку *master*, если процессы интеграции реализованы правильным образом и эффективно обеспечивают контроль качества. Изоляция работы над новой функциональностью также позволяет эффективно использовать запросы на объединение кода (*pull request, merge request*), которые являются способом инициализации обсуждения изменений, созданных в ветке. Они дают другим разработчикам возможность одобрить функциональность перед интегрирацией в официальный проект. Или, если в процессе работы над функциональностью разработчик столкнулся с проблемой, он может создать запрос на объединение и спросить совета у коллег. Суть в том, что запросы на объединение позволяют участникам команды комментировать работу друг друга.<br/>
*Gitflow* отлично подходит для проектов, которые имеют спланированный цикл релиза. Эта модель не предполагает дополнительных понятий, кроме тех, что описаны для модели *Feature Branch Workflow*. Вместо этого она приписывает особые роли разным веткам и определяет, как и когда они должны взаимодействовать: *feature-, release-,hotfix-ветки*, то есть отдельные ветки для подготовки, поддержки и записи релиза. Конечно, также необходимо эффективно использовать все преимущества *Feature Branch Workflow*: пул-реквесты, изоляция для изменений и эффективное сотрудничество внутри команды.
4. *Forking Workflow* - в ее рамках  разработка ведется так, что есть два репозитория:
+ Оригинальный репозиторий, в который будут смердживаться все изменения.
+ Форк репозиторий (это копия оригинального репозитория во владении другого разработчика, который хочет внести изменения в оригинальный).<br/>

Такая стратегия дает следующее премущество: разработка может вестись в форк-репозитории и без предоставления прав на совместную разработку в оригинальном.Это удобно и владельцу оригинального репозитория, и разработчику, который хочет поучаствовать в создании какого-то продукта.

Подробнее о других моделях ветвления - [здесь](https://proglib.io/p/git-workflow).
